### **1. `solution` 메서드**

```
public int[] solution(int n, int m) {
    int gcd = getGCD(n, m); // 최대공약수 구하기
    int lcm = (n * m) / gcd; // 최소공배수 구하기
    return new int[] { gcd, lcm }; // 결과 배열 반환
}
```

- **목적**: 주어진 두 수 `n`과 `m`의 최대공약수와 최소공배수를 구하여 배열로 반환

1. **최대공약수 구하기**
   `getGCD(n, m)`를 호출해서 최대공약수(GCD)를 구할 수 있음.

2. **최소공배수 구하기**
   최대공약수(GCD)를 알고 있으면, 최소공배수(LCM)는 아래 공식으로 사용!
   [image-20250203165937380](C:\Users\JIMIN\AppData\Roaming\Typora\typora-user-images\image-20250203165937380.png)

   즉, `n`과 `m`의 곱을 그들의 최대공약수로 나누면 최소공배수가 됨

3. **결과 반환**
   `gcd`와 `lcm`을 배열로 묶어 반환

------

### **2. `getGCD` 메서드 (유클리드 호제법 사용)**

```
java복사편집private int getGCD(int n, int m) {
    while (m != 0) {
        int temp = m;
        m = n % m;
        n = temp;
    }
    return n;
}
```

- **목적**: 주어진 두 수 `n`과 `m`의 최대공약수(GCD)를 구하는 방법으로 **유클리드 호제법**을 사용(소인수분해를 이용한 풀이는 너무 복잡...)

1. **유클리드 호제법**: 두 수 `n`과 `m`의 GCD를 구할 때, `m`이 0이 될 때까지 반복적으로 `n % m`을 구하고, `m`을 그 값으로, `n`을 이전의 `m` 값으로 바꿔주면 됨

   - `n % m`은 `n`을 `m`으로 나눈 나머지를 구하는 연산

   - 예를 들어, 

     ```
     n = 48
     ```

     ```
     m = 18
     ```

     이라면, 반복적으로 다음과 같은 과정을 거침:

     - 48 % 18 = 12 → (n = 18, m = 12)
     - 18 % 12 = 6 → (n = 12, m = 6)
     - 12 % 6 = 0 → 종료 (최대공약수는 6)

2. **반복 종료**: `m`이 0이 되면 그때의 `n` 값이 두 수의 최대공약수(GCD)가 됨

------

### **예시 실행**

#### 입력: `n = 48`, `m = 18`

1. **최대공약수 (GCD) 구하기**:

   - ```
     getGCD(48, 18)
     ```

     을 호출:

     - 48 % 18 = 12 → (n = 18, m = 12)
     - 18 % 12 = 6 → (n = 12, m = 6)
     - 12 % 6 = 0 → (최대공약수 GCD = 6)

2. **최소공배수 (LCM) 구하기**:

   - `LCM(48, 18) = (48 * 18) / 6 = 864 / 6 = 144`

3. **결과 반환**:

   - `gcd = 6`, `lcm = 144` → `{6, 144}` 배열 반환

------

### **정리**

- `solution` 메서드는 두 수의 최대공약수와 최소공배수를 구하여 배열로 반환
- `getGCD` 메서드는 유클리드 호제법을 사용하여 두 수의 최대공약수(GCD)를 구할 수 있음
- 이 코드의 방식은 효율적이고 빠르게 GCD와 LCM을 구할 수 있는 방법이다!